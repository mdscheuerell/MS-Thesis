#Convert both delta notation values into R notation
R2 <- (4.315/1000)+1
R2
Rout <- (10.301/1000)+1
Rout
M.I1/M.out
#Use equation R = fI1*RI1 + fI2*RI2 to solve for the R value of the sample if there was not the confounding factor of atmospheric N
fI1 <- M.I1/M.out
#Use equation R = fI1*RI1 + fI2*RI2 to solve for the R value of the sample if there was not the confounding factor of atmospheric N
fI1 <- M.I1/M.out
fI2 <- M.I2/M.out
(Rout-(fI2*R2))/fI1
trueRsamp <- (Rout-(fI2*R2))/fI1
#convert the corrected Rsamp to delta
truedelta <- (trueRsamp*1000) + 1
truedelta
trueRsamp
#convert the corrected Rsamp to delta
truedelta <- (trueRsamp + 1) * 1000
truedelta
#convert the corrected Rsamp to delta
truedelta <- (trueRsamp 1 1) * 1000
truedelta
#convert the corrected Rsamp to delta
truedelta <- (trueRsamp - 1) * 1000
truedelta
#find the difference to figure out how much our original measurement was off by
diff <- truedelta - 10.301
diff
#the random variable in this model is the observations of wolves
# extract the observations Nt from the data frame
nt.obs <- wa_wolf$Abundance
#load data
load("~/Documents/GitHub/FISH 454/Code/wa_wolf.rda")
#the random variable in this model is the observations of wolves
#extract the observations Nt from the data frame
nt.obs <- wa_wolf$Abundance
#the random variable in this model is the observations of wolves
#extract the observations Nt from the data frame
nt.obs <- wa_wolf$Abundance
#the random variable in this model is the observations of wolves
#extract the observations Nt from the data frame
nt.obs <- wa_wolf$Abundance
#write function to calculate nll
obs.dd.nll <- function(pars, nt.obs) {
r <- pars[1]
N1 <- pars[2]
K <- pars[3]
nt <- rep(NA, length(nt.obs))
for(i in 2:length(nt)){
nt[1] <- N1
nt[i] <- nt.obs[i - 1] + r * nt.obs[i - 1] * (1 - (nt.obs[i - 1]/K))
}
nll <- -sum(dpois(x = nt.obs, lambda = nt, log = TRUE))
return(nll)
}
#test function
start.pars <- c(0.25, 5, 135)
obs.dd.nll(start.pars, nt.obs)
#write function to calculate nll
obs.dd.nll <- function(pars, nt.obs) {
r <- pars[1]
N1 <- pars[2]
K <- pars[3]
nt <- rep(NA, length(nt.obs))
nt[1] <- N1
for(i in 2:length(nt)){
nt[i] <- nt[i - 1] + r * nt[i - 1] * (1 - (nt[i - 1]/K))
}
nll <- -sum(dpois(x = nt.obs, lambda = nt, log = TRUE))
return(nll)
}
#write function to calculate nll
obs.dd.nll <- function(pars, nt.obs) {
r <- pars[1]
N1 <- pars[2]
K <- pars[3]
nt <- rep(NA, length(nt.obs))
nt[1] <- N1
for(i in 2:length(nt)){
nt[i] <- nt[i - 1] + r * nt[i - 1] * (1 - (nt[i - 1]/K))
}
nll <- -sum(dpois(x = nt.obs, lambda = nt, log = TRUE))
return(nll)
}
#test function
start.pars <- c(0.25, 5, 135)
obs.dd.nll(start.pars, nt.obs)
#use optim to maximize nll
start.pars.dd <- c(0.25, 4, 135)
obs.fit.dd <- optim(par = start.pars.dd,
fn = obs.dd.nll,
nt = nt,
K = K,
method = "BFGS") #density independent, observation based model
#use optim to maximize nll
start.pars.dd <- c(0.25, 4, 135)
obs.fit.dd <- optim(par = start.pars.dd,
fn = obs.dd.nll,
nt = nt,
method = "BFGS") #density independent, observation based model
#use optim to maximize nll
start.pars.dd <- c(0.25, 4, 135)
obs.fit.dd <- optim(par = start.pars.dd,
fn = obs.dd.nll,
nt = nt.obs,
method = "BFGS") #density independent, observation based model
warnings()
#load data
load("~/Documents/GitHub/FISH 454/Code/wa_wolf.rda")
#the random variable in this model is the observations of wolves
#extract the observations Nt from the data frame
nt.obs <- wa_wolf$Abundance
#write function to calculate nll
obs.dd.nll <- function(pars, nt.obs) {
r <- pars[1]
N1 <- pars[2]
K <- pars[3]
nt <- rep(NA, length(nt.obs))
nt[1] <- N1
for(i in 2:length(nt)){
nt[i] <- nt[i - 1] + r * nt[i - 1] * (1 - (nt[i - 1]/K))
}
nll <- -sum(dpois(x = nt.obs, lambda = nt, log = TRUE))
return(nll)
}
#use optim to maximize nll
start.pars.dd <- c(0.25, 4, 135)
obs.fit.dd <- optim(par = start.pars.dd,
fn = obs.dd.nll,
nt.obs = nt.obs,
method = "BFGS") #density independent, observation based model
obs <- obs.fit.dd$value
obs
warnings()
obs
obs.dd.fit <- optim(par = start.pars.dd,
fn = obs.dd.nll,
nt.obs = nt.obs,
method = "BFGS") #density independent, observation based model
obs <- obs.dd.fit$value
obs
#calculating AIC
obs.AIC <- 2 * (obs + 3)
obs.AIC
#finding delta AIC value using old
process <- 86.020
#finding delta AIC value using old
process.AIC <- 86.020
obs.AIC
DAIC <- process.AIC - obs.AIC
DAIC
load("~/Documents/GitHub/FISH 454/Data/harborseals.rda")
View(harborseals)
#density independent
process.di.nll <- function(pars, nt){
r <- pars[1]
N0 <- pars[2]
nt.hat <- rep(NA, length(nt))
nt.hat[1] <- N0 + r*N0
for(i in 2:length(nt)){
nt.hat[i] <- nt[i-1] + r*nt[i-1]
}
nll <- -sum(dpois(x = nt, lambda = nt.hat, log = TRUE))
return(nll)
}
nt <- harborseals$abundance
nt <- harborseals$abundance
start.pars.dd <- c(0.25, 4000)
process.di.fit <- optim(par = start.pars,
fn = process.di.nll,
nt = nt,
method = "BFGS") #density independent, process based model
start.pars.di <- c(0.25, 4000)
process.di.fit <- optim(par = start.pars.di,
fn = process.di.nll,
nt = nt,
method = "BFGS") #density independent, process based model
process.di <- process.di.fit$value
process.di
process.di.fit
#density dependent
process.dd.nll <- function(pars, nt, K){
r <- pars[1]
N0 <- pars[2]
K <- pars[3]
nt.hat <- rep(NA, length(nt))
nt.hat[1] <- N0 + r * N0 * (1 - (N0/K))
for(i in 2:length(nt)){
nt.hat[i] <- nt[i-1] + r * nt[i-1] * (1 - (nt[i-1]/K))
}
nll <- -sum(dpois(x = nt, lambda = nt.hat, log = TRUE))
return(nll)
}
start.pars.dd <- c(0.25, 4, 3000)
start.pars.dd <- c(0.25, 3000, 3000)
process.dd.fit <- optim(par = start.pars.dd,
fn = process.dd.nll,
nt = nt,
K = K,
method = "BFGS") #density independent, process based model
process.dd <- process.dd.fit$value
process.dd
#calculate AIC for density independent
AIC.di.process <- 2 * (process.di + 2)
#calculate AIC for density dependent
AIC.dd.process <- 2 * (process.dd + 3)
#DAIC calculations
AIC.di - AIC.dd
#calculate AIC for density dependent
AIC.dd.process <- 2 * (process.dd + 3)
#DAIC calculations
AIC.di.process - AIC.dd.process
#DAIC calculations
AIC.dd.process - AIC.di.process
#### Observation Error Model ####
nt.obs <- wa_wolf$Abundance
#### Observation Error Model ####
nt.obs <- harborseals$abundance
#density dependent
obs.dd.nll <- function(pars, nt.obs) {
r <- pars[1]
N1 <- pars[2]
K <- pars[3]
nt <- rep(NA, length(nt.obs))
nt[1] <- N1
for(i in 2:length(nt)){
nt[i] <- nt[i - 1] + r * nt[i - 1] * (1 - (nt[i - 1]/K))
}
nll <- -sum(dpois(x = nt.obs, lambda = nt, log = TRUE))
return(nll)
}
start.pars.dd <- c(0.25, 4000, 4000)
obs.dd.fit <- optim(par = start.pars.dd,
fn = obs.dd.nll,
nt.obs = nt.obs,
method = "BFGS") #density independent, observation based model
obs.dd <- obs.dd.fit$value
obs.dd
#density independent
obs.di.nll <- function(pars, nt.obs) {
r <- pars[1]
N1 <- pars[2]
nt <- rep(NA, length(nt.obs))
nt[1] <- N1
for(i in 2:length(nt)){
nt[i] <- nt[i - 1] + r * nt[i - 1]
}
nll <- -sum(dpois(x = nt.obs, lambda = nt, log = TRUE))
return(nll)
}
start.pars.di <- c(0.25, 4000, 4000)
start.pars.di <- c(0.25, 4000)
start.pars.di <- c(0.25, 4000)
obs.di.fit <- optim(par = start.pars.di,
fn = obs.di.nll,
nt.obs = nt.obs,
method = "BFGS") #density independent, observation based model
obs.di <- obs.di.fit$value
obs.di
#calculate AIC for density independent
AIC.di.obs <- 2 * (obs.di + 2)
#calculate AIC for density dependent
AIC.dd.obs <- 2 * (obs.dd + 3)
#DAIC calculations
AIC.dd.obs - AIC.di.obs
#DAIC calculations
AIC.di.obs - AIC.dd.obs
obs.dd.nll(start.pars.di, nt.obs)
obs.dd.nll(start.pars.di, nt.obs)
obs.di.nll(start.pars.di, nt.obs)
start.pars.di <- c(1, 4000)
obs.di.nll(start.pars.di, nt.obs)
obs.di.nll(start.pars.di, nt.obs)
start.pars.di <- c(1, 4000)
obs.di.fit <- optim(par = start.pars.di,
fn = obs.di.nll,
nt.obs = nt.obs,
method = "BFGS") #density independent, observation based model
obs.di <- obs.di.fit$value
obs.di
#calculate AIC for density independent
AIC.di.obs <- 2 * (obs.di + 2)
#calculate AIC for density dependent
AIC.dd.obs <- 2 * (obs.dd + 3)
#DAIC calculations
AIC.di.obs - AIC.dd.obs
obs.di.fit <- optim(par = start.pars.di,
fn = obs.di.nll,
nt.obs = nt.obs,
method = "BFGS") #density independent, observation based model
obs.di
start.pars.di <- c(0.25, 4000)
obs.di.fit <- optim(par = start.pars.di,
fn = obs.di.nll,
nt.obs = nt.obs,
method = "BFGS") #density independent, observation based model
obs.di <- obs.di.fit$value
obs.di
obs.di.fit <- optim(par = start.pars.di,
fn = obs.di.nll,
nt.obs = nt.obs,
method = "BFGS") #density independent, observation based model
obs.di.fit <- optim(par = start.pars.di,
fn = obs.di.nll,
nt.obs = nt.obs,
method = "BFGS") #density independent, observation based model
obs.di <- obs.di.fit$value
#calculate AIC for density independent
AIC.di.obs <- 2 * (obs.di + 2)
#calculate AIC for density dependent
AIC.dd.obs <- 2 * (obs.dd + 3)
#DAIC calculations
AIC.di.obs - AIC.dd.obs
#density dependent
obs.dd.nll <- function(pars, nt.obs) {
r <- pars[1]
N1 <- pars[2]
K <- pars[3]
nt <- rep(NA, length(nt.obs))
nt[1] <- N1
for(i in 2:length(nt)){
nt[i] <- nt[i - 1] + r * nt[i - 1] * (1 - (nt[i - 1]/K))
}
nll <- -sum(dpois(x = nt.obs, lambda = nt, log = TRUE))
return(nll)
}
start.pars.dd <- c(0.25, 4000, 8000)
obs.dd.fit <- optim(par = start.pars.dd,
fn = obs.dd.nll,
nt.obs = nt.obs,
method = "BFGS") #density independent, observation based model
obs.dd <- obs.dd.fit$value
obs.dd
#calculate AIC for density independent
AIC.di.obs <- 2 * (obs.di + 2)
#calculate AIC for density dependent
AIC.dd.obs <- 2 * (obs.dd + 3)
#DAIC calculations
AIC.di.obs - AIC.dd.obs
process.dd.fit
process.dd.fit$par[1]
nt.hat <- rep(NA, length(nt))
#show the fits
r <- process.dd.fit$par[1]
N0 <- process.dd.fit$par[2]
K <- process.dd.fit$par[3]
nt.hat <- rep(NA, length(nt))
nt.hat
nt.hat[1] <- N0 + r * N0 * (1 - (N0/K))
nt.hat
for(i in 2:length(nt)){
nt.hat[i] <- nt[i-1] + r * nt[i-1] * (1 - (nt[i-1]/K))
}
nt.hat.dd <- rep(NA, length(nt))
nt.hat.dd[1] <- N0 + r * N0 * (1 - (N0/K))
for(i in 2:length(nt)){
nt.hat.dd[i] <- nt[i-1] + r * nt[i-1] * (1 - (nt[i-1]/K))
}
plot(x = nt.hat.dd,
y = nt)
plot(x = nt.hat.dd,
y = nt)
abline(lm(nt ~ nt.hat.dd), col = "red")
plot(x = harborseals$year,
y = nt.obs)
obs.di.fit
#showing data as plots
r <- obs.di.fit$par[1]
N1 <- obs.di.fit$par[2]
nt <- rep(NA, length(nt.obs))
nt[1] <- N1
for(i in 2:length(nt)){
nt[i] <- nt[i - 1] + r * nt[i - 1]
}
nt
plot(x = harborseals$year,
y = nt.obs)
lines(nt)
?lines
plot(x = harborseals$year,
y = nt.obs)
lines(x = harborseals$year,
y = nt, col = "red")
#showing data as plots
r.di <- obs.di.fit$par[1]
N1.di <- obs.di.fit$par[2]
nt.di <- rep(NA, length(nt.obs))
nt.di[1] <- N1.di
for(i in 2:length(nt)){
nt.di[i] <- nt.di[i - 1] + r.di * nt.di[i - 1]
}
proc.di.plot <- plot(x = harborseals$year,
y = nt.obs)
lines(x = harborseals$year,
y = nt.di, col = "red")
obs.dd.fit
obs.dd.fit$par[1]
r.dd <- obs.dd.fit$par[1]
N1.dd <- obs.dd.fit$par[2]
K.dd <- obs.dd.fit$par[3]
nt.dd <- rep(NA, length(nt.obs))
nt.dd[1] <- N1
for(i in 2:length(nt.dd)){
nt.dd[i] <- nt.dd[i - 1] + r.dd * nt.dd[i - 1] * (1 - (nt.dd[i - 1]/K.dd))
}
process.plot <- plot(x = harborseals$year,
y = nt.obs)
lines(x = harborseals$year,
y = nt.di, col = "red")
lines(x = harborseals$year,
y = nt.dd, col = "blue")
legend("topright",
legend = c("Density Independent", "Density Dependent"),
col = c("red", "blue"),
lty = 1,
cex = 1.2)
legend("topleft",
legend = c("Density Independent", "Density Dependent"),
col = c("red", "blue"),
lty = 1,
cex = 1.2)
process.plot <- plot(x = harborseals$year,
y = nt.obs)
lines(x = harborseals$year,
y = nt.di, col = "red")
lines(x = harborseals$year,
y = nt.dd, col = "blue")
legend("topleft",
legend = c("Density Independent", "Density Dependent"),
col = c("red", "blue"),
lty = 1,
cex = 1.2)
process.plot <- plot(x = harborseals$year,
y = nt.obs,
xlab = "Year", ylab = "Population")
lines(x = harborseals$year,
y = nt.di, col = "red")
lines(x = harborseals$year,
y = nt.dd, col = "blue")
legend("topleft",
legend = c("Density Independent", "Density Dependent"),
col = c("red", "blue"),
lty = 1,
cex = 1.2)
observation.plot <- plot(x = harborseals$year,
y = nt.obs,
xlab = "Year", ylab = "Population")
lines(x = harborseals$year,
y = nt.di, col = "red")
lines(x = harborseals$year,
y = nt.dd, col = "blue")
legend("topleft",
legend = c("Density Independent", "Density Dependent"),
col = c("red", "blue"),
lty = 1,
cex = 1.2)
a <- read.csv(file = "~/Documents/Grad School /SIA/HEEL_NACHO_program/Data/20240403_GHenry_20240403.csv")
a <- read.csv(file = "~/Documents/GitHub/CSIA_lab_work/data/EA results/cleaned/240403_GHenry_20240403.csv")
View(a)
HEEL::EA.NACHO("~/Documents/GitHub/CSIA_lab_work/data/EA results/cleaned/240403_GHenry_20240403.csv")
#processing the bulk data using the HEEL package
devtools::install_github("gholtgrieve/HEEL")
rm(list=ls())
library(HEEL)
#run this code for all csv files in the "cleaned" folder
HEEL::EA.NACHO("~/Documents/GitHub/CSIA_lab_work/data/EA results/cleaned/240410_GHenry_20240410.csv")
y
#run this code for all csv files in the "cleaned" folder
HEEL::EA.NACHO("~/Documents/GitHub/CSIA_lab_work/data/EA results/cleaned/240410_GHenry_20240410.csv")
#extract data from all csv files
setwd("~/Documents/GitHub/CSIA_lab_work/data/EA results/processed")
apr10 <- read.csv(file = "04:10:2024/sample_CN.csv")
apr08 <- read.csv(file = "04:08:2024/sample_CN.csv")
apr03 <- read.csv(file = "04:03:2024/sample_CN.csv")
mar29 <- read.csv(file = "03:29:2024/sample_CN.csv")
mar28 <- read.csv(file = "03:28:2024/sample_CN.csv")
mar27 <- read.csv(file = "03:27:2024/sample_CN.csv")
mar26 <- read.csv(file = "03:26:2024/sample_CN.csv")
mar25 <- read.csv(file = "03:25:2024/sample_CN.csv")
#combine into one sheet
library(dplyr)
combined_df <- bind_rows(apr03, apr08, mar25, mar26, mar27, mar28, mar29)
#group samples
grouped_df <- combined_df %>%
group_by(group_id = substr(Identifier.1, 1, 7)) %>%
summarize_all(mean, na.rm = TRUE)
#get rid of extra columns
grouped_df <- grouped_df[,-c(2:7)]
View(grouped_df)
View(apr10)
View(grouped_df)
#remove AA standards and make own sheet
AA_STDS <- grouped_df[22:71,]
View(AA_STDS)
#make sheet of no AAs
sample_df <- grouped_df[1:21,]
View(sample_df)
grouped_AAs <- AA_STDS %>%
group_by(group_id = substr(Identifier.1, 1, 3)) %>%
summarize_all(mean, na.rm = TRUE)
grouped_AAs <- AA_STDS %>%
group_by(ID = substr(group_id, 1, 3)) %>%
summarize_all(mean, na.rm = TRUE)
View(grouped_AAs)
View(grouped_AAs)
View(combined_df)
View(grouped_AAs)
View(AA_STDS)
View(grouped_AAs)
rm(list = ls())
setwd("~/Documents/GitHub/CSIA_lab_work/data")
