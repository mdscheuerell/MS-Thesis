lines(x = 1:nyears, y = SE.scenario.2, col = "red")
# Add legend
legend("bottomleft", legend = c("Average", "Worst Case", "Best Case"), col = c("blue", "red", "black"), lty = 1,
bty = "n", x.intersp = 0.5, y.intersp = 0.5, cex = 0.8)
plot(x = 1:nyears, y = SE.scenario.3, type = "l", ylim = c(1000, 2000), xlab = "Years", ylab = "Population", main = "Population Scenarios")
lines(x = 1:nyears, y = SE.scenario.1, col = "blue")
lines(x = 1:nyears, y = SE.scenario.2, col = "red")
# Add legend
legend("bottomleft", legend = c("Average", "Worst Case", "Best Case"), col = c("blue", "red", "black"), lty = 1,
bty = "n", x.intersp = 0.5, y.intersp = 0.5, cex = 0.8)
plot(x = 1:nyears, y = SE.scenario.3, type = "l", ylim = c(1000, 2000), xlab = "Years", ylab = "Population", main = "Population Scenarios")
lines(x = 1:nyears, y = SE.scenario.1, col = "blue")
lines(x = 1:nyears, y = SE.scenario.2, col = "red")
# Add legend
legend("bottomleft", legend = c("Average", "Worst Case", "Best Case"), col = c("blue", "red", "black"), lty = 1,
bty = "n", x.intersp = 0.5, y.intersp = 0.5, cex = 0.8)
# calculate % change
100 * (SE.scenario.3[ nyears ] - SE.scenario.3[ 1 ]) / SE.scenario.3[ 1 ]
# calculate % change
100 * (SE.scenario.2[ nyears ] - SE.scenario.2[ 1 ]) / SE.scenario.2[ 1 ]
# calculate % change
100 * (SE.scenario.1[ nyears ] - SE.scenario.1[ 1 ]) / SE.scenario.1[ 1 ]
# calculate % change
N.1.change <- 100 * (N.scenario.1[ nyears ] - N.scenario.1[ 1 ]) / N.scenario.1[ 1 ]
# calculate % change
N.2.change <- 100 * (N.scenario.2[ nyears ] - N.scenario.2[ 1 ]) / N.scenario.2[ 1 ]
# calculate % change
N.3.change <- 100 * (N.scenario.3[ nyears ] - N.scenario.3[ 1 ]) / N.scenario.3[ 1 ]
# calculate % change
SW.1.change <- 100 * (SW.scenario.1[ nyears ] - SW.scenario.1[ 1 ]) / SW.scenario.1[ 1 ]
SW.2.change <- SW.scenario.2 <- pop.model(r = r,
K = K,
N0 = N0,
nyears = nyears,
E = E,
q = q)
# calculate % change
SW.2.change <- 100 * (SW.scenario.2[ nyears ] - SW.scenario.2[ 1 ]) / SW.scenario.2[ 1 ]
SW.scenario.2 <- pop.model(r = r,
K = K,
N0 = N0,
nyears = nyears,
E = E,
q = q)
# calculate % change
SW.2.change <- 100 * (SW.scenario.2[ nyears ] - SW.scenario.2[ 1 ]) / SW.scenario.2[ 1 ]
SW.2.change
# calculate % change
SW.3.change <- 100 * (SW.scenario.3[ nyears ] - SW.scenario.3[ 1 ]) / SW.scenario.3[ 1 ]
# calculate % change
SE.1.change <- 100 * (SE.scenario.1[ nyears ] - SE.scenario.1[ 1 ]) / SE.scenario.1[ 1 ]
# calculate % change
SE.2.change <- 100 * (SE.scenario.2[ nyears ] - SE.scenario.2[ 1 ]) / SE.scenario.2[ 1 ]
# calculate % change
SE.3.change <- 100 * (SE.scenario.3[ nyears ] - SE.scenario.3[ 1 ]) / SE.scenario.3[ 1 ]
change <- data.frame(N.1.change,
N.2.change,
N.3.change,
SW.1.change,
SW.2.change,
SW.3.change,
SE.1.change,
SE.2.change,
SE.3.change)
View(change)
library(tidyr)
# Assuming your data frame is named 'change'
flipped_df <- pivot_longer(change, everything(), names_to = "ID", values_to = "Value")
flipped_df
View(flipped_df)
# flip df
flipped_df <- pivot_longer(change, everything(), names_to = "ID", values_to = "Value")
print(flipped_df)
# flip df
flipped_df <- pivot_longer(change, everything(), names_to = "ID", values_to = "Pop percent change")
#load data
load("~/Documents/GitHub/FISH 454/Data/harborseals.rda")
source("~/Downloads/plotmodelfitFuns.R", echo=TRUE)
#load data
load("~/Documents/GitHub/FISH 454/Data/harborseals.rda")
#### Process Error Model ####
nt <- harborseals$abundance
#density independent
process.di.nll <- function(pars, nt){
r <- pars[1]
N0 <- pars[2]
nt.hat <- rep(NA, length(nt))
nt.hat[1] <- N0 + r*N0
for(i in 2:length(nt)){
nt.hat[i] <- nt[i-1] + r*nt[i-1]
}
nll <- -sum(dpois(x = nt, lambda = nt.hat, log = TRUE))
return(nll)
}
start.pars.di <- c(0.25, 4000)
process.di.fit <- optim(par = start.pars.di,
fn = process.di.nll,
nt = nt,
method = "BFGS") #density independent, process based model
process.di <- process.di.fit$value
#density dependent
process.dd.nll <- function(pars, nt, K){
r <- pars[1]
N0 <- pars[2]
K <- pars[3]
nt.hat <- rep(NA, length(nt))
nt.hat[1] <- N0 + r * N0 * (1 - (N0/K))
for(i in 2:length(nt)){
nt.hat[i] <- nt[i-1] + r * nt[i-1] * (1 - (nt[i-1]/K))
}
nll <- -sum(dpois(x = nt, lambda = nt.hat, log = TRUE))
return(nll)
}
start.pars.dd <- c(0.25, 3000, 10000)
process.dd.fit <- optim(par = start.pars.dd,
fn = process.dd.nll,
nt = nt,
K = K,
method = "BFGS") #density independent, process based model
process.dd <- process.dd.fit$value
process.dd
#calculate AIC for density independent
AIC.di.process <- 2 * (process.di + 2)
#calculate AIC for density dependent
AIC.dd.process <- 2 * (process.dd + 3)
AIC.dd.process
AIC.di.process
#### Observation Error Model ####
nt.obs <- harborseals$abundance
#density dependent
obs.dd.nll <- function(pars, nt.obs) {
r <- pars[1]
N1 <- pars[2]
K <- pars[3]
nt <- rep(NA, length(nt.obs))
nt[1] <- N1
for(i in 2:length(nt)){
nt[i] <- nt[i - 1] + r * nt[i - 1] * (1 - (nt[i - 1]/K))
}
nll <- -sum(dpois(x = nt.obs, lambda = nt, log = TRUE))
return(nll)
}
start.pars.dd <- c(0.25, 4000, 10000)
obs.dd.fit <- optim(par = start.pars.dd,
fn = obs.dd.nll,
nt.obs = nt.obs,
method = "BFGS") #density dependent, observation based model
obs.dd <- obs.dd.fit$value
#density independent
obs.di.nll <- function(pars, nt.obs) {
r <- pars[1]
N1 <- pars[2]
nt <- rep(NA, length(nt.obs))
nt[1] <- N1
for(i in 2:length(nt)){
nt[i] <- nt[i - 1] + r * nt[i - 1]
}
nll <- -sum(dpois(x = nt.obs, lambda = nt, log = TRUE))
return(nll)
}
start.pars.di <- c(0.25, 4000)
obs.di.fit <- optim(par = start.pars.di,
fn = obs.di.nll,
nt.obs = nt.obs,
method = "BFGS") #density independent, observation based model
obs.di <- obs.di.fit$value
#calculate AIC for density independent
AIC.di.obs <- 2 * (obs.di + 2)
#calculate AIC for density dependent
AIC.dd.obs <- 2 * (obs.dd + 3)
AIC.dd.obs
AIC.di.obs
rlist <- seq(from = 0.3, to = 2, length.out = 100)
klist <- seq(from = 10000, to = 11000, length.out = 100)
nll.profile <- matrix(NA, nrow = 100, ncol = 100)
for(i in 1:length(rlist)){
r <- rlist[i]
for (j in 1:length(klist)) {
K <- klist[j]
nll.profile[i,j] <- process.dd.nll(pars = c(process.dd.fit$par[1], process.dd.fit$par[2]),
nt = nt.obs,
K = t)
}
}
nll.profile
for(i in 1:length(rlist)){
r <- rlist[i]
for (j in 1:length(klist)) {
K <- klist[j]
nll.profile[i,j] <- process.dd.nll(pars = c(process.dd.fit$par[1], process.dd.fit$par[2]),
nt = nt.obs,
K = K)
}
}
nll.profile
#density dependent
process.dd.nll <- function(pars){
r <- pars[1]
N0 <- pars[2]
K <- pars[3]
nt.hat <- rep(NA, length(nt))
nt.hat[1] <- N0 + r * N0 * (1 - (N0/K))
for(i in 2:length(nt)){
nt.hat[i] <- nt[i-1] + r * nt[i-1] * (1 - (nt[i-1]/K))
}
nll <- -sum(dpois(x = nt, lambda = nt.hat, log = TRUE))
return(nll)
}
r <- rlist[1]
K <- klist[1]
process.dd.nll(pars = c(rlist, process.dd.fit$par[2], klist),
nt = nt.obs)
process.dd.nll <- function(pars, nt){
r <- pars[1]
N0 <- pars[2]
K <- pars[3]
nt.hat <- rep(NA, length(nt))
nt.hat[1] <- N0 + r * N0 * (1 - (N0/K))
for(i in 2:length(nt)){
nt.hat[i] <- nt[i-1] + r * nt[i-1] * (1 - (nt[i-1]/K))
}
nll <- -sum(dpois(x = nt, lambda = nt.hat, log = TRUE))
return(nll)
}
process.dd.nll(pars = c(rlist, process.dd.fit$par[2], klist),
nt = nt.obs)
process.dd.fit$par[2]
r <- rlist[1]
r
K <- klist[1]
K
r <- rlist[1]
K <- klist[1]
process.dd.nll(pars = c(r, process.dd.fit$par[2], k),
nt = nt)
process.dd.nll(pars = c(r, process.dd.fit$par[2], K),
nt = nt)
rlist <- seq(from = 0.3, to = 2, length.out = 100)
klist <- seq(from = 10000, to = 11000, length.out = 100)
nll.profile <- matrix(NA, nrow = 100, ncol = 100)
for(i in 1:length(rlist)){
r <- rlist[i]
for (j in 1:length(klist)) {
K <- klist[j]
nll.profile[i,j] <- process.dd.nll(pars = c(rlist, process.dd.fit$par[2], klist),
nt = nt.obs)
}
}
rlist <- seq(from = 0.3, to = 2, length.out = 100)
klist <- seq(from = 10000, to = 11000, length.out = 100)
nll.profile <- matrix(NA, nrow = 100, ncol = 100)
for(i in 1:length(rlist)){
r <- rlist[i]
for (j in 1:length(klist)) {
K <- klist[j]
nll.profile[i,j] <- process.dd.nll(pars = c(rlist, process.dd.fit$par[2], klist),
nt = nt.obs)
}
}
nll.profile
klist
rlist
for(i in 1:length(rlist)){
r <- rlist[i]
for (j in 1:length(klist)) {
K <- klist[j]
nll.profile[i,j] <- process.dd.nll(pars = c(rlist, process.dd.fit$par[2], klist),
nt = nt)
}
}
nll.profile
rlist <- seq(from = 0.5, to = 2, length.out = 100)
klist <- seq(from = 9000, to = 10000, length.out = 100)
nll.profile <- matrix(NA, nrow = 100, ncol = 100)
for(i in 1:length(rlist)){
r <- rlist[i]
for (j in 1:length(klist)) {
K <- klist[j]
nll.profile[i,j] <- process.dd.nll(pars = c(rlist, process.dd.fit$par[2], klist),
nt = nt)
}
}
nll.profile
process.dd.fit$par[2]
for(i in 1:length(rlist)){
r <- rlist[i]
for (j in 1:length(klist)) {
K <- klist[j]
nll.profile[i,j] <- process.dd.nll(pars = c(r, process.dd.fit$par[2], K),
nt = nt)
}
}
nll.profile
r.profile = apply(X = nll.profile, MARGIN = 1, FUN = min)
plot(rlist, r.profile, type = "l", lwd = 2)
process.dd.fit$par[1]
rlist <- seq(from = 0.1, to = 2, length.out = 100)
klist <- seq(from = 9000, to = 10000, length.out = 100)
nll.profile <- matrix(NA, nrow = 100, ncol = 100)
for(i in 1:length(rlist)){
r <- rlist[i]
for (j in 1:length(klist)) {
K <- klist[j]
nll.profile[i,j] <- process.dd.nll(pars = c(r, process.dd.fit$par[2], K),
nt = nt)
}
}
r.profile = apply(X = nll.profile, MARGIN = 1, FUN = min)
plot(rlist, r.profile, type = "l", lwd = 2)
rlist <- seq(from = 0, to = 2, length.out = 100)
klist <- seq(from = 9000, to = 10000, length.out = 100)
nll.profile <- matrix(NA, nrow = 100, ncol = 100)
for(i in 1:length(rlist)){
r <- rlist[i]
for (j in 1:length(klist)) {
K <- klist[j]
nll.profile[i,j] <- process.dd.nll(pars = c(r, process.dd.fit$par[2], K),
nt = nt)
}
}
r.profile = apply(X = nll.profile, MARGIN = 1, FUN = min)
plot(rlist, r.profile, type = "l", lwd = 2)
rlist <- seq(from = 0, to = 1, length.out = 100)
klist <- seq(from = 9000, to = 10000, length.out = 100)
nll.profile <- matrix(NA, nrow = 100, ncol = 100)
for(i in 1:length(rlist)){
r <- rlist[i]
for (j in 1:length(klist)) {
K <- klist[j]
nll.profile[i,j] <- process.dd.nll(pars = c(r, process.dd.fit$par[2], K),
nt = nt)
}
}
r.profile = apply(X = nll.profile, MARGIN = 1, FUN = min)
plot(rlist, r.profile, type = "l", lwd = 2)
rlist <- seq(from = 0, to = 0.8, length.out = 100)
klist <- seq(from = 9000, to = 10000, length.out = 100)
nll.profile <- matrix(NA, nrow = 100, ncol = 100)
for(i in 1:length(rlist)){
r <- rlist[i]
for (j in 1:length(klist)) {
K <- klist[j]
nll.profile[i,j] <- process.dd.nll(pars = c(r, process.dd.fit$par[2], K),
nt = nt)
}
}
r.profile = apply(X = nll.profile, MARGIN = 1, FUN = min)
plot(rlist, r.profile, type = "l", lwd = 2)
rlist <- seq(from = 0, to = 0.7, length.out = 100)
klist <- seq(from = 9000, to = 10000, length.out = 100)
nll.profile <- matrix(NA, nrow = 100, ncol = 100)
for(i in 1:length(rlist)){
r <- rlist[i]
for (j in 1:length(klist)) {
K <- klist[j]
nll.profile[i,j] <- process.dd.nll(pars = c(r, process.dd.fit$par[2], K),
nt = nt)
}
}
r.profile = apply(X = nll.profile, MARGIN = 1, FUN = min)
plot(rlist, r.profile, type = "l", lwd = 2)
r.profile
min(r.profile)
minNLL <- min(r.profile)
# get confidence interval
min.nll <- minNLL
target.nll <- min.nll + 1.92
index <- which(r.profile <= target.nll)
rci <- rlist[c(index[1], index[length(index)])]
print(rci)
rlist <- seq(from = 0, to = 0.7, length.out = 200)
klist <- seq(from = 9000, to = 10000, length.out = 200)
nll.profile <- matrix(NA, nrow = 100, ncol = 100)
for(i in 1:length(rlist)){
r <- rlist[i]
for (j in 1:length(klist)) {
K <- klist[j]
nll.profile[i,j] <- process.dd.nll(pars = c(r, process.dd.fit$par[2], K),
nt = nt)
}
}
r.profile = apply(X = nll.profile, MARGIN = 1, FUN = min)
plot(rlist, r.profile, type = "l", lwd = 2)
process.dd.fit$par[3]
rlist <- seq(from = 0, to = 0.7, length.out = 200)
klist <- seq(from = 7000, to = 10000, length.out = 200)
nll.profile <- matrix(NA, nrow = 200, ncol = 200)
for(i in 1:length(rlist)){
r <- rlist[i]
for (j in 1:length(klist)) {
K <- klist[j]
nll.profile[i,j] <- process.dd.nll(pars = c(r, process.dd.fit$par[2], K),
nt = nt)
}
}
r.profile = apply(X = nll.profile, MARGIN = 1, FUN = min)
plot(rlist, r.profile, type = "l", lwd = 2)
minNLL <- min(r.profile)
# get confidence interval
min.nll <- minNLL
target.nll <- min.nll + 1.92
index <- which(r.profile <= target.nll)
rci <- rlist[c(index[1], index[length(index)])]
print(rci)
min.nll + 1.92
lines(min.nll + 1.92)
plot(rlist, r.profile, type = "l", lwd = 2)
abline(min.nll + 1.92)
plot(rlist, r.profile, type = "l", lwd = 2)
abline(h = minNLL, col = "red", lty = 2)
min.nll
rlist <- seq(from = 0, to = 0.4, length.out = 200)
klist <- seq(from = 7000, to = 10000, length.out = 200)
nll.profile <- matrix(NA, nrow = 200, ncol = 200)
for(i in 1:length(rlist)){
r <- rlist[i]
for (j in 1:length(klist)) {
K <- klist[j]
nll.profile[i,j] <- process.dd.nll(pars = c(r, process.dd.fit$par[2], K),
nt = nt)
}
}
r.profile = apply(X = nll.profile, MARGIN = 1, FUN = min)
plot(rlist, r.profile, type = "l", lwd = 2)
abline(h = minNLL, col = "red", lty = 2)
rlist <- seq(from = 0, to = 0.6, length.out = 200)
klist <- seq(from = 7000, to = 10000, length.out = 200)
nll.profile <- matrix(NA, nrow = 200, ncol = 200)
for(i in 1:length(rlist)){
r <- rlist[i]
for (j in 1:length(klist)) {
K <- klist[j]
nll.profile[i,j] <- process.dd.nll(pars = c(r, process.dd.fit$par[2], K),
nt = nt)
}
}
r.profile = apply(X = nll.profile, MARGIN = 1, FUN = min)
plot(rlist, r.profile, type = "l", lwd = 2)
abline(h = minNLL, col = "red", lty = 2)
r.profile
r.profile = apply(X = nll.profile, MARGIN = 1, FUN = min)
plot(rlist, r.profile, type = "l", lwd = 2,
ylim = c(700, 800))
abline(h = minNLL, col = "red", lty = 2)
r.profile = apply(X = nll.profile, MARGIN = 1, FUN = min)
plot(rlist, r.profile, type = "l", lwd = 2)
abline(h = target.nll, col = "red", lty = 2)
r.profile = apply(X = nll.profile, MARGIN = 1, FUN = min)
plot(rlist, r.profile, type = "l", lwd = 2)
r.profile = apply(X = nll.profile, MARGIN = 1, FUN = min)
plot(rlist, r.profile, type = "l", lwd = 2,
r.profile = apply(X = nll.profile, MARGIN = 1, FUN = min)
plot(rlist, r.profile, type = "l", lwd = 2,
abline(h = target.nll, col = "red", lty = 2)
r.profile = apply(X = nll.profile, MARGIN = 1, FUN = min)
plot(rlist, r.profile, type = "l", lwd = 2,
ylim = c(700,730))
abline(h = target.nll, col = "red", lty = 2)
r.profile = apply(X = nll.profile, MARGIN = 1, FUN = min)
plot(rlist, r.profile, type = "l", lwd = 2,
xlim = c(0.15, 0.3),
ylim = c(700,730))
abline(h = target.nll, col = "red", lty = 2)
r.profile = apply(X = nll.profile, MARGIN = 1, FUN = min)
plot(rlist, r.profile, type = "l", lwd = 2,
xlim = c(0.15, 0.4),
ylim = c(705,730))
abline(h = target.nll, col = "red", lty = 2)
r.profile = apply(X = nll.profile, MARGIN = 1, FUN = min)
plot(rlist, r.profile, type = "l", lwd = 2,
xlim = c(0.15, 0.4),
ylim = c(710,730))
abline(h = target.nll, col = "red", lty = 2)
# plot
r.profile = apply(X = nll.profile, MARGIN = 1, FUN = min)
plot(rlist, r.profile, type = "l", lwd = 2,
xlim = c(0.2, 0.35),
ylim = c(710,730))
abline(h = target.nll, col = "red", lty = 2)
process.dd
AIC.dd.process
AIC.di.obs - AIC.dd.process
AIC.dd.obs - AIC.dd.process
AIC.dd.process - AIC.dd.process
AIC.di.process - AIC.dd.process
obs.dd.fit$pars
obs.dd.fit$par
obs.di.fit$par
process.di.fit$pars
process.di.fit$par
process.dd.fit$par
minNLL
# get confidence interval
min.nll <- minNLL
target.nll <- min.nll + 1.92
index <- which(r.profile <= target.nll)
rci <- rlist[c(index[1], index[length(index)])]
print(rci)
setwd("~/Documents/GitHub/CSIA_lab_work/data/final")
data <- read.csv(file = "all.data.csv")
View(data)
ggplot(data, aes(x = Year,
y = PHE.mean))
library(ggplot2)
ggplot(data, aes(x = Year,
y = PHE.mean))
library(ggplot2)
ggplot(data, aes(x = Year,
y = PHE.mean)) +
geom_point(size = 3, alpha = 0.7)
setwd("~/Documents/GitHub/CSIA_lab_work/data")
rm(list = ls())
