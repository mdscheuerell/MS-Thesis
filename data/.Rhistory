mean.d13C.SAM = mean(d13C_SAM),
annual.sd.d13C.SAM = sd(d13C_SAM))
#find the difference between each time step
diff.CO2.ML <- vector(length = 39)
for(i in 1:39){
diff.CO2.ML[i] <- annual_data$mean.CO2.ML[i+1]-annual_data$mean.CO2.ML[i]
}
diff.CO2.SAM <- vector(length = 39)
for(i in 1:39){
diff.CO2.SAM[i] <- annual_data$mean.CO2.SAM[i+1]-annual_data$mean.CO2.SAM[i]
}
diff.d13C_ML <- vector(length = 39)
for(i in 1:39){
diff.d13C_ML[i] <- annual_data$mean.d13C.ML[i+1]-annual_data$mean.d13C.ML[i]
}
diff.d13C_SAM <- vector(length = 39)
for(i in 1:39){
diff.d13C_SAM[i] <- annual_data$mean.d13C.SAM[i+1]-annual_data$mean.d13C.SAM[i]
}
#average each set of differences to find the average change per year
mean(diff.CO2.ML[1:38])
mean(diff.CO2.SAM[1:38])
mean(diff.d13C_ML[1:38])
mean(diff.d13C_SAM[1:38])
```
print(coef(sourceLM.ML)[1]) # this is the y-intercept which is the source d13C value at ML
#ML
y.axis.ML <- data$d13C_ML
x.axis.ML <- 1/(data$CO2_ML)
sourceLM.ML <- lm((y.axis.ML ~
x.axis.ML))
print(coef(sourceLM.ML)[1]) # this is the y-intercept which is the source d13C value at ML
summary(sourceLM.ML)$coeff[1,2] #this is standard error of the y-intercept
#SAM
y.axis.SAM <- data$d13C_SAM
x.axis.SAM <- 1/data$CO2_SAM
sourceLM.SAM <- lm((y.axis.SAM ~ x.axis.SAM))
print(coef(sourceLM.SAM)[1]) # this is the y-intercept which is the source d13C value at SAM
summary(sourceLM.SAM)$coeff[1,2] #this is standard error of the y-intercept
#mean of each year subtract this from each data point
data$annual_mean_CO2_ML <- annual_data$mean.CO2.ML[match(data$Year, annual_data$Year)]
View(data)
data$annual_mean_d13C_ML <- annual_data$mean.d13C.ML[match(data$Year, annual_data$Year)]
data$annual_mean_CO2_SAM <- annual_data$mean.CO2.SAM[match(data$Year, annual_data$Year)]
data$annual_mean_d13C_SAM <- annual_data$mean.d13C.SAM[match(data$Year, annual_data$Year)]
ML_CO2 <- data$CO2_ML - data$annual_mean_CO2_ML
ML_CO2
ML_d13C <- data$d13C_ML - data$annual_mean_d13C_ML
ML_d13C
#take the original data point and subtract the mean
#creates vectors of data that are detrended
detrend_ML <- data$CO2_ML - data$annual_mean_CO2_ML
detrend_SAM <- data$CO2_SAM - data$annual_mean_CO2_SAM
detrend_d13C_ML <- data$d13C_ML - data$annual_mean_d13C_ML
detrend_d13C_SAM <- data$d13C_ML - data$annual_mean_d13C_SAM
#make a new data frame with the detrended data
detrend <- data.frame(detrend_d13C_ML, detrend_ML, detrend_d13C_SAM,detrend_SAM, data$Year)
#plot
ggplot(detrend, aes(x = data.Year, y = detrend_d13C_ML)) +
geom_point(color = "red") +
geom_point(aes(data.Year, detrend_ML), color = "blue")
ggplot(detrend, aes(x = data.Year, y = detrend_d13C_SAM)) +
geom_point(color = "red") +
geom_point(aes(data.Year, detrend_SAM), color = "blue")
View(detrend)
#plot for ML
ggplot(detrend, aes(x = data.Year, y = detrend_d13C_ML)) +
geom_point(color = "red") +
geom_point(aes(data.Year, detrend_ML))
x.lm.ML <- 1/detrend$detrend_ML
y.lm.ML <- detrend$detrend_d13C_ML
ggplot(detrend, aes(x = data.Year, y = detrend_d13C_SAM)) +
geom_point(color = "red") +
geom_point(aes(data.Year, detrend_SAM), color = "blue")
x.lm.ML <- 1/detrend$detrend_ML
y.lm.ML <- detrend$detrend_d13C_ML
LM.ML <- lm(y.lm.ML ~ x.lm.ML)
plot(detrend$data.Year,detrend$detrend_SAM)
print(coef(LM.ML))[1])
print(coef(LM.ML))[1]
print(coef(LM.ML)[1])
summary(LM.ML)$coeff[1,2]
View(data)
#find the y-intercepts for SAM
x.lm.SAM <- 1/detrend$detrend_SAM
y.lm.SAM <- detrend$detrend_d13C_SAM
LM.SAM <- lm(y.lm.SAM ~ x.lm.SAM)
print(coef(SAM.ML)[1])
LM.SAM <- lm(y.lm.SAM ~ x.lm.SAM)
print(coef(LM.SAM)[1])
summary(LM.SAM)$coeff[1,2]
print(coef(LM.ML)[1])
#plot
ggplot(detrend, aes(x = data.Year, y = detrend_d13C_ML)) +
geom_point(color = "red") +
geom_point(aes(data.Year, detrend_ML), color = "blue")
#plot
ggplot(detrend, aes(x = data.Year, y = detrend_d13C_ML)) +
geom_point(color = "red") +
geom_point(aes(data.Year, detrend_ML), color = "blue")
ggplot(detrend, aes(x = data.Year, y = detrend_d13C_SAM)) +
geom_point(color = "red") +
geom_point(aes(data.Year, detrend_SAM), color = "blue")
#method 2: cumulative for hydrogen
frac.cum.H <- (log((R.D.H[11]/R.D.H[1])/log(depth[11]/depth[1]))/10)+1
D.H <- c(-86.00, -84.70, -83.40, -81.70, -80.00, -78.70, -77.80,
-75.60, -73.50, -71.90, -72.10)
R.D.H <- (D.H/1000)+1
#method 1: sequential for hydrogen
frac.H <- vector(length= length(D.H))
for(i in 2:length(D.H)){
frac.H[i] <- log((R.D.H[i]/R.D.H[i-1])/log(depth[i]/depth[i-1]))+1
}
frac.H
#Set up vectors and then a data frame for the given numbers
depth <- seq(from = 5, to = 4, by = -0.1)
O18.O16 <- c(-12.00, -11.60, -11.20, -10.90, -10.30, -10.04,
-9.50, -9.00, -8.80, -8.20, -7.90)
D.H <- c(-86.00, -84.70, -83.40, -81.70, -80.00, -78.70, -77.80,
-75.60, -73.50, -71.90, -72.10)
R.D.H <- (D.H/1000)+1
#method 1: sequential for hydrogen
frac.H <- vector(length= length(D.H))
for(i in 2:length(D.H)){
frac.H[i] <- log((R.D.H[i]/R.D.H[i-1])/log(depth[i]/depth[i-1]))+1
}
frac.H
#method 1: sequential time intervals
frac <- vector(length = length(R.O18.O16))
for(i in 2:length(O18.O16)){
frac[i] <- log((R.O18.O16[i]/R.O18.O16[i-1]))/log(depth[i]/depth[i-1])+1
}
#Set up vectors and then a data frame for the given numbers
depth <- seq(from = 5, to = 4, by = -0.1)
function (..., list = character(), package = NULL, lib.loc = NULL,
verbose = getOption("verbose"), envir = .GlobalEnv, overwrite = TRUE)
knitr::opts_chunk$set(echo = TRUE)
#Set up vectors and then a data frame for the given numbers
depth <- seq(from = 5, to = 4, by = -0.1)
O18.O16 <- c(-12.00, -11.60, -11.20, -10.90, -10.30, -10.04,
-9.50, -9.00, -8.80, -8.20, -7.90)
R.O18.O16 <- (O18.O16/1000)+1
D.H <- c(-86.00, -84.70, -83.40, -81.70, -80.00, -78.70, -77.80,
-75.60, -73.50, -71.90, -72.10)
R.D.H <- (D.H/1000)+1
df <- data.frame(depth, O18.O16, D.H, R.O18.O16, R.D.H)
#method 1: sequential time intervals
frac <- vector(length = length(R.O18.O16))
for(i in 2:length(O18.O16)){
frac[i] <- log((R.O18.O16[i]/R.O18.O16[i-1]))/log(depth[i]/depth[i-1])+1
}
log((R.O18.O16[2]/R.O18.O16[1])/(depth[2]/depth[1]))+1
mean.frac <- mean(frac[2:11])
sd.frac <- sd(frac[2:11])
frac
mean.frac <- mean(frac[2:11])
mean.frac
#method 2: cumulative from initial condition
a <- R.O18.O16[11]/R.O18.O16[1]
b <- depth[11]/depth[1]
frac.cum <- (log(a)/log(b))+1 #divide by 10 because that is the number of total time steps that we are doing?
#convert frac values into delta notation
d.frac <- (mean.frac-1)*1000
d.frac
#method 1: sequential for hydrogen
frac.H <- vector(length= length(D.H))
for(i in 2:length(D.H)){
frac.H[i] <- log((R.D.H[i]/R.D.H[i-1]))/log(depth[i]/depth[i-1])+1
}
mean.frac.H <- mean(frac.H[2:11])
sd.frac.H <- sd(frac.H[2:11])
#method 2: cumulative for hydrogen
frac.cum.H <- (log((R.D.H[11]/R.D.H[1])/log(depth[11]/depth[1]))/10)+1
#method 2: cumulative for hydrogen
c <- R.D.H[11]/R.D.H[1]
d <- depth[11]/depth[1]
frac.cum.H <- ((log(c)/log(d))/10)+1
frac.cum.H
mean.frac.H
mean.frac
frac.cum
#method 1: sequential for hydrogen
frac.H <- vector(length= length(D.H))
for(i in 2:length(D.H)){
frac.H[i] <- log((R.D.H[i]/R.D.H[i-1]))/log(depth[i]/depth[i-1])+1
}
mean.frac.H <- mean(frac.H[2:11])
sd.frac.H <- sd(frac.H[2:11])
#method 2: cumulative for hydrogen
c <- R.D.H[11]/R.D.H[1]
d <- depth[11]/depth[1]
frac.cum.H <- ((log(c)/log(d))/10)+1
frac.cum.H
mean.frac.H
frac.H
sd.frac.H <- sd(frac.H[2:11])
sd.frac.H
R.D.H
frac.cum.H <- (log(c)/log(d))+1
<- mean(frac.H[2:11])
mean.frac.H
frac.cum.H
#convert frac values into delta notation
d.frac.H <- (mean.frac.H-1)*1000
d.frac.H
epsilon.O <- d.frac
epsilon.H <- d.frac.H
#Calculations of instantaneous product for oxygen
O18.O16 <- c(-12.00, -11.60, -11.20, -10.90, -10.30, -10.04,
-9.50, -9.00, -8.80, -8.20, -7.90)
inst.prod.O <- O18.O16 - epsilon.O
library(dplyr)
library(dplyr)
#Calculating cumulative product of O above the pool
cum.product.O <- cummean(inst.prod.O)
blank.correct <- read.csv(file = "~/Documents/GitHub/Isotope class/data/ProblemSet2/BlankCorrection.csv")
View(blank.correct)
blank.correct$Area.28[1]
blank.correct$Area.28[2]
M.I2 <- blank.correct$Area.28[1]
M.out <- blank.correct$Area.28[2]
M.out-M.I2
M.I2 <- blank.correct$Area.28[1]
M.out <- blank.correct$Area.28[2]
# use fraction 1 plus fraction 2 = 1 equation to solve for area under the curve if our sample had truly been JUST sample
M.I1 <- M.out-M.I2
M.I1
#Convert both delta notation values into R notation
R2 <- (4.315/1000)+1
R2
Rout <- (10.301/1000)+1
Rout
M.I1/M.out
#Use equation R = fI1*RI1 + fI2*RI2 to solve for the R value of the sample if there was not the confounding factor of atmospheric N
fI1 <- M.I1/M.out
#Use equation R = fI1*RI1 + fI2*RI2 to solve for the R value of the sample if there was not the confounding factor of atmospheric N
fI1 <- M.I1/M.out
fI2 <- M.I2/M.out
(Rout-(fI2*R2))/fI1
trueRsamp <- (Rout-(fI2*R2))/fI1
#convert the corrected Rsamp to delta
truedelta <- (trueRsamp*1000) + 1
truedelta
trueRsamp
#convert the corrected Rsamp to delta
truedelta <- (trueRsamp + 1) * 1000
truedelta
#convert the corrected Rsamp to delta
truedelta <- (trueRsamp 1 1) * 1000
truedelta
#convert the corrected Rsamp to delta
truedelta <- (trueRsamp - 1) * 1000
truedelta
#find the difference to figure out how much our original measurement was off by
diff <- truedelta - 10.301
diff
rm(list = ls())
setwd("~/Documents/GitHub/CSIA_lab_work/data")
library(dplyr)
name <- c("Analysis", "ID1", "RT", "AreaAll", "d29N", "d15N", "AAID")
#This is the stable isotope ratios of the internal and external standards.
# MAKE SURE THIS IS UP TO DATE BASED ON HEEL STANDARDS!!! These values are as of 01/23/2020.
#If your samples were esterfied after 01/23/2020 these values should be verfied with the standard file on the HEEL drive
ALA <- -1.21
VAL <- 0.361
NOR <- 14.163
PHE <- -5.004
GLU <- -3.336
#Reading in the .csv of the NACHO data file and setting the file name for your output file
data.1 <- SL.1 <- read.csv("cleaned/20240207_GHenry_CSIA.csv") #modify with name of your data file
colnames(data.1)<- name
file.name <- "cleaned/20240207_GHenry_CSIA.csv" #file name for output file including relative file path
#### Correct to international standard of N air ####
#Calculations of offset values were done in R script "Correct_to_Nair.R"
#Three EA runs were looked at, the second was chosen as the most representative to base corrections off
#No linear relationship was found between offset and measured value so one average value
#will be applied to raw data
#The offset values were calculated as EA measured d15N - reference
offset <- mean(c(0.40160, 0.47160, 0.41725))
data.1$d15N.correct <- data.1$d15N - offset
View(data.1)
data.1STD <- subset(data.1, ID1=="5AA") #get only the standard data
AA <- unique(unlist(data.1STD$AAID)) #make a list of the AAs in the data
Intercept<-data.frame(Intercept=rep(NA,length(AA))) #initiate a dataframe for the intercepts of the linear model
for(i in 1:length(AA)){
data <- subset(data.1STD, AAID==AA[i])
Intercept[i,1]<- coef(summary(lm(as.numeric(d15N.correct)~as.numeric(Analysis), data=data)))[1,1]
}
Intercept
Slope<-data.frame(Slope=rep(NA,length(AA))) #initiate a dataframe for the slopes of the linear model
for(i in 1:length(AA)){
data <- subset(data.1STD, AAID==AA[i])
Slope[i,1]<- coef(summary(lm(as.numeric(d15N.correct)~as.numeric(Analysis), data=data)))[2,1]
}
Slope #slope values looped by aa
Coef<- data.frame(AA, Intercept, Slope) #creating a dataframe of the slope and intercepts values for each AA
Coef
actual <- ifelse(data.1$AAID=="NOR", NOR,
ifelse(data.1$AAID=="ALA", ALA,
ifelse(data.1$AAID=="VAL", VAL,
ifelse(data.1$AAID=="PHE", PHE,
ifelse(data.1$AAID=="GLU", GLU,0)))))
actual
View(data.1)
slope <- ifelse(data.1$AAID=="NOR", filter(Coef, AA=="NOR")[1,3],
ifelse(data.1$AAID=="ALA", filter(Coef, AA=="ALA")[1,3],
ifelse(data.1$AAID=="VAL", filter(Coef, AA=="VAL")[1,3],
ifelse(data.1$AAID=="GLU", filter(Coef, AA=="GLU")[1,3],
ifelse(data.1$AAID=="PHE", filter(Coef, AA=="PHE")[1,3], 0)))))
intercept <-   ifelse(data.1$AAID=="NOR", filter(Coef, AA=="NOR")[1,2],
ifelse(data.1$AAID=="ALA", filter(Coef, AA=="ALA")[1,2],
ifelse(data.1$AAID=="VAL", filter(Coef, AA=="VAL")[1,2],
ifelse(data.1$AAID=="GLU", filter(Coef, AA=="GLU")[1,2],
ifelse(data.1$AAID=="PHE", filter(Coef, AA=="PHE")[1,2], 0)))))
intercept
#####Applying Drift Correction####
difference <- actual-(data.1$Analysis*slope+intercept) #Applying both a drift and step correction in on estep from linear model data
adj <- data.1$d15N.correct + difference
data <- cbind(data.1, adj)
data
View(data)
View(data)
#####Applying Drift Correction####
difference <- actual-(data.1$Analysis*slope+intercept) #Applying both a drift and step correction in on estep from linear model data
adj <- data.1$d15N.correct + difference
data <- cbind(data.1, adj)
data
write.csv(data, file = file.name)
rm(list = ls())
function (..., list = character(), package = NULL, lib.loc = NULL,
verbose = getOption("verbose"), envir = .GlobalEnv, overwrite = TRUE)
{
fileExt <- function(x) {
db <- grepl("\\.[^.]+\\.(gz|bz2|xz)$", x)
ans <- sub(".*\\.", "", x)
ans[db] <- sub(".*\\.([^.]+\\.)(gz|bz2|xz)$", "\\1\\2",
x[db])
ans
}
my_read_table <- function(...) {
lcc <- Sys.getlocale("LC_COLLATE")
on.exit(Sys.setlocale("LC_COLLATE", lcc))
Sys.setlocale("LC_COLLATE", "C")
read.table(...)
}
stopifnot(is.character(list))
names <- c(as.character(substitute(list(...))[-1L]), list)
if (!is.null(package)) {
if (!is.character(package))
stop("'package' must be a character vector or NULL")
}
paths <- find.package(package, lib.loc, verbose = verbose)
if (is.null(lib.loc))
paths <- c(path.package(package, TRUE), if (!length(package)) getwd(),
paths)
paths <- unique(normalizePath(paths[file.exists(paths)]))
paths <- paths[dir.exists(file.path(paths, "data"))]
dataExts <- tools:::.make_file_exts("data")
if (length(names) == 0L) {
db <- matrix(character(), nrow = 0L, ncol = 4L)
for (path in paths) {
entries <- NULL
packageName <- if (file_test("-f", file.path(path,
"DESCRIPTION")))
basename(path)
else "."
if (file_test("-f", INDEX <- file.path(path, "Meta",
"data.rds"))) {
entries <- readRDS(INDEX)
}
else {
dataDir <- file.path(path, "data")
entries <- tools::list_files_with_type(dataDir,
"data")
if (length(entries)) {
entries <- unique(tools::file_path_sans_ext(basename(entries)))
entries <- cbind(entries, "")
}
}
if (NROW(entries)) {
if (is.matrix(entries) && ncol(entries) == 2L)
db <- rbind(db, cbind(packageName, dirname(path),
entries))
else warning(gettextf("data index for package %s is invalid and will be ignored",
sQuote(packageName)), domain = NA, call. = FALSE)
}
}
colnames(db) <- c("Package", "LibPath", "Item", "Title")
footer <- if (missing(package))
paste0("Use ", sQuote(paste("data(package =", ".packages(all.available = TRUE))")),
"\n", "to list the data sets in all *available* packages.")
else NULL
y <- list(title = "Data sets", header = NULL, results = db,
footer = footer)
class(y) <- "packageIQR"
return(y)
}
paths <- file.path(paths, "data")
for (name in names) {
found <- FALSE
for (p in paths) {
tmp_env <- if (overwrite)
envir
else new.env()
if (file_test("-f", file.path(p, "Rdata.rds"))) {
rds <- readRDS(file.path(p, "Rdata.rds"))
if (name %in% names(rds)) {
found <- TRUE
if (verbose)
message(sprintf("name=%s:\t found in Rdata.rds",
name), domain = NA)
thispkg <- sub(".*/([^/]*)/data$", "\\1",
p)
thispkg <- sub("_.*$", "", thispkg)
thispkg <- paste0("package:", thispkg)
objs <- rds[[name]]
lazyLoad(file.path(p, "Rdata"), envir = tmp_env,
filter = function(x) x %in% objs)
break
}
else if (verbose)
message(sprintf("name=%s:\t NOT found in names() of Rdata.rds, i.e.,\n\t%s\n",
name, paste(names(rds), collapse = ",")),
domain = NA)
}
if (file_test("-f", file.path(p, "Rdata.zip"))) {
warning("zipped data found for package ", sQuote(basename(dirname(p))),
".\nThat is defunct, so please re-install the package.",
domain = NA)
if (file_test("-f", fp <- file.path(p, "filelist")))
files <- file.path(p, scan(fp, what = "",
quiet = TRUE))
else {
warning(gettextf("file 'filelist' is missing for directory %s",
sQuote(p)), domain = NA)
next
}
}
else {
files <- list.files(p, full.names = TRUE)
}
files <- files[grep(name, files, fixed = TRUE)]
if (length(files) > 1L) {
o <- match(fileExt(files), dataExts, nomatch = 100L)
paths0 <- dirname(files)
paths0 <- factor(paths0, levels = unique(paths0))
files <- files[order(paths0, o)]
}
if (length(files)) {
for (file in files) {
if (verbose)
message("name=", name, ":\t file= ...",
.Platform$file.sep, basename(file), "::\t",
appendLF = FALSE, domain = NA)
ext <- fileExt(file)
if (basename(file) != paste0(name, ".", ext))
found <- FALSE
else {
found <- TRUE
zfile <- file
zipname <- file.path(dirname(file), "Rdata.zip")
if (file.exists(zipname)) {
Rdatadir <- tempfile("Rdata")
dir.create(Rdatadir, showWarnings = FALSE)
topic <- basename(file)
rc <- .External(C_unzip, zipname, topic,
Rdatadir, FALSE, TRUE, FALSE, FALSE)
if (rc == 0L)
zfile <- file.path(Rdatadir, topic)
}
if (zfile != file)
on.exit(unlink(zfile))
switch(ext, R = , r = {
library("utils")
sys.source(zfile, chdir = TRUE, envir = tmp_env)
}, RData = , rdata = , rda = load(zfile,
envir = tmp_env), TXT = , txt = , tab = ,
tab.gz = , tab.bz2 = , tab.xz = , txt.gz = ,
txt.bz2 = , txt.xz = assign(name, my_read_table(zfile,
header = TRUE, as.is = FALSE), envir = tmp_env),
CSV = , csv = , csv.gz = , csv.bz2 = ,
csv.xz = assign(name, my_read_table(zfile,
header = TRUE, sep = ";", as.is = FALSE),
envir = tmp_env), found <- FALSE)
}
if (found)
break
}
if (verbose)
message(if (!found)
"*NOT* ", "found", domain = NA)
}
if (found)
break
}
if (!found) {
warning(gettextf("data set %s not found", sQuote(name)),
domain = NA)
}
else if (!overwrite) {
for (o in ls(envir = tmp_env, all.names = TRUE)) {
if (exists(o, envir = envir, inherits = FALSE))
warning(gettextf("an object named %s already exists and will not be overwritten",
sQuote(o)))
else assign(o, get(o, envir = tmp_env, inherits = FALSE),
envir = envir)
}
rm(tmp_env)
}
}
invisible(names)
}
