frac <- vector(length = length(R.O18.O16))
for(i in 2:length(O18.O16)){
frac[i] <- log((R.O18.O16[i-1]/R.O18.O16[i])/(depth[i-1]/depth[i]))+1
}
frac
#method 2: cumulative from initial condition
frac.cum <- ((log((R.O18.O16[1]/R.O18.O16[11])/(depth[1]/depth[11]))))+1 #divide by 10 because that is the number of total time steps that we are doing?
frac.cum
mean.frac <- mean(frac[2:11])
sd.frac <- sd(frac[2:11])
#method 2: cumulative from initial condition
frac.cum <- ((log((R.O18.O16[1]/R.O18.O16[11])/(depth[1]/depth[11]))))+1 #divide by 10 because that is the number of total time steps that we are doing?
frac.cum
#method 2: cumulative from initial condition
a <- R.O18.O16[1]/R.O18.O16[11]
b <- depth[1]/depth[11]
frac.cum <- (log(a/b)+1 #divide by 10 because that is the number of total time steps that we are doing?
frac.cum
#method 2: cumulative from initial condition
a <- R.O18.O16[1]/R.O18.O16[11]
b <- depth[1]/depth[11]
frac.cum <- (log(a/b)+1 #divide by 10 because that is the number of total time steps that we are doing?
frac.cum
#method 2: cumulative from initial condition
a <- R.O18.O16[1]/R.O18.O16[11]
b <- depth[1]/depth[11]
frac.cum <- (log(a/b))+1 #divide by 10 because that is the number of total time steps that we are doing?
frac.cum
#method 1: sequential time intervals
frac <- vector(length = length(R.O18.O16))
for(i in 2:length(O18.O16)){
frac[i] <- log((R.O18.O16[i]/R.O18.O16[i-1])/(depth[i]/depth[i-1]))+1
}
frac
mean.frac <- mean(frac[2:11])
sd.frac <- sd(frac[2:11])
#method 2: cumulative from initial condition
a <- R.O18.O16[11]/R.O18.O16[1]
b <- depth[11]/depth[1]
frac.cum <- (log(a/b))+1 #divide by 10 because that is the number of total time steps that we are doing?
frac.cum
b
a
a
R.O18.O16[11]
R.O18.O16[1]
R.O18.O16[11]
R.O18.O16[11]/R.O18.O16[1]
a
b <- depth[11]/depth[1]
a
b
frac.cum
frac.cum <- (log10(a/b))+1 #divide by 10 because that is the number of total time steps that we are doing?
frac.cum
(log(a)/log(b))+1
#method 1: sequential time intervals
frac <- vector(length = length(R.O18.O16))
for(i in 2:length(O18.O16)){
frac[i] <- log((R.O18.O16[i]/R.O18.O16[i-1]))/log(depth[i]/depth[i-1])+1
}
frac
frac.cum <- (log(a)/log(b))+1 #divide by 10 because that is the number of total time steps that we are doing?
frac.cum
data <- read.csv(file = "~/Documents/GitHub/Isotope class/data/ProblemSet2/atmospheric_CO2.csv")
function (x, df1, df2, ncp, log = FALSE)
knitr::opts_chunk$set(echo = TRUE)
data <- read.csv(file = "~/Documents/GitHub/Isotope class/data/ProblemSet2/atmospheric_CO2.csv")
library(ggplot2)
library(ggplot2)
# Create a plot with CO2_ML and CO2_SAM
plot_co2 <- ggplot(data, aes(x = Year)) +
geom_point(aes(y = CO2_ML), col = "red") +
geom_point(aes(y = CO2_SAM), col = "blue") +
ylab("CO2")
# Combine the two plots with separate y-axes
combined_plot <- plot_co2 +
geom_point(aes(y = d13C_ML), col = "green") +
geom_point(aes(y = d13C_SAM), col = "purple") +
scale_y_continuous(
name = "CO2",
sec.axis = sec_axis(~., name = "d13C", labels = scales::number_format())
)
# Print the combined plot
print(combined_plot)
library(tidyverse)
#finding the mean and standard deviation within each year, make a new data frame with this infro
annual_data <- data %>%
group_by(Year) %>%
summarise(
mean.CO2.ML = mean(CO2_ML),
annual.sd.CO2.ML = sd(CO2_ML),
mean.CO2.SAM = mean(CO2_SAM),
annual.sd.CO2.SAM = sd(CO2_SAM),
mean.d13C.ML = mean(d13C_ML),
annual.sd.d13C.ML = sd(d13C_ML),
mean.d13C.SAM = mean(d13C_SAM),
annual.sd.d13C.SAM = sd(d13C_SAM))
#find the difference between each time step
diff.CO2.ML <- vector(length = 39)
for(i in 1:39){
diff.CO2.ML[i] <- annual_data$mean.CO2.ML[i+1]-annual_data$mean.CO2.ML[i]
}
diff.CO2.SAM <- vector(length = 39)
for(i in 1:39){
diff.CO2.SAM[i] <- annual_data$mean.CO2.SAM[i+1]-annual_data$mean.CO2.SAM[i]
}
diff.d13C_ML <- vector(length = 39)
for(i in 1:39){
diff.d13C_ML[i] <- annual_data$mean.d13C.ML[i+1]-annual_data$mean.d13C.ML[i]
}
diff.d13C_SAM <- vector(length = 39)
for(i in 1:39){
diff.d13C_SAM[i] <- annual_data$mean.d13C.SAM[i+1]-annual_data$mean.d13C.SAM[i]
}
diff.CO2.ML
mean(diff.CO2.ML[1:38])
mean(diff.CO2.SAM[1:38])
mean(diff.d13C_ML[1:38])
mean(diff.d13C_SAM[1:38])
#ML
y.axis.ML <- data$d13C_ML
x.axis.ML <- 1/(data$CO2_ML)
y.axis.ML
x.axis.ML
x.axis.ML
sourceLM.ML <- lm((x.axis.ML ~
y.axis.ML))
View(sourceLM.ML)
plot(sourceLM.ML)
sourceLM.ML <- lm((y.axis.ML ~
x.axis.ML))
print(coef(sourceLM.ML)[2]) # this is the y-intercept which is the source d13C value at ML
print(coef(sourceLM.ML)[1]) # this is the y-intercept which is the source d13C value at ML
View(sourceLM.ML)
summary(sourceLM.ML)$coeff
summary(sourceLM.ML)$coeff[2]
summary(sourceLM.ML)
summary(sourceLM.ML)$coeff
summary(sourceLM.ML)$coeff[1,2]
print(coef(sourceLM.ML)[1])
#SAM
y.axis.SAM <- data$d13C_SAM
x.axis.SAM <- 1/data$CO2_ML
sourceLM.SAM <- lm((y.axis.SAM ~ x.axis.SAM))
sourceLM.SAM
print(coef(sourceLM.SAM)[1]) # this is the y-intercept which is the source d13C value at SAM
summary(sourceLM.SAM)$coeff[1,2] #this is standard error of the y-intercept
print(coef(sourceLM.SAM)[1]) # this is the y-intercept which is the source d13C value at SAM
x.axis.SAM <- 1/data$CO2_SAM
sourceLM.SAM <- lm((y.axis.SAM ~ x.axis.SAM))
print(coef(sourceLM.SAM)[1]) # this is the y-intercept which is the source d13C value at SAM
summary(sourceLM.SAM)$coeff[1,2] #this is standard error of the y-intercept
print(coef(sourceLM.ML)[1])
#detrending for ML d13C
detrend_d13C_ML <- as.vector(detrend(log(data$d13C_ML)))
library(pracma)
#detrending for ML d13C
detrend_d13C_ML <- as.vector(detrend(log(data$d13C_ML)))
detrend_d13C_ML
View(annual_data)
data$annual_mean_d13C_ML <- annual_data$mean.d13C.ML[match(annual_data$Year, data$Year)]
#mean of each year subtract this from each data point
data$annual_mean_d13C_ML <- annual_data$mean.d13C.ML[match(annual_data$Year, data$Year)]
#mean of each year subtract this from each data point
data$annual_mean_CO2_ML <- annual_data$mean.CO2.ML[match(annual_data$Year, data$Year)]
#mean of each year subtract this from each data point
data$annual_mean_CO2_ML <- annual_data$mean.CO2.ML[match(data$Year, annual_data$Year)]
knitr::opts_chunk$set(echo = TRUE)
data <- read.csv(file = "~/Documents/GitHub/Isotope class/data/ProblemSet2/atmospheric_CO2.csv")
data <- read.csv(file = "~/Documents/GitHub/Isotope class/data/ProblemSet2/atmospheric_CO2.csv")
library(ggplot2)
data <- read.csv(file = "~/Documents/GitHub/Isotope class/data/ProblemSet2/atmospheric_CO2.csv")
library(ggplot2)
# Create a plot with CO2_ML and CO2_SAM
plot_co2 <- ggplot(data, aes(x = Year)) +
geom_point(aes(y = CO2_ML), col = "red") +
geom_point(aes(y = CO2_SAM), col = "blue") +
ylab("CO2")
# Create a plot with d13C_ML and d13C_SAM
plot_d13C <- ggplot(data, aes(x = Year)) +
geom_point(aes(y = d13C_ML), col = "red") +
geom_point(aes(y = d13C_SAM), col = "blue") +
ylab("d13C")
# Combine the two plots with separate y-axes
combined_plot <- plot_co2 +
geom_point(aes(y = d13C_ML), col = "green") +
geom_point(aes(y = d13C_SAM), col = "purple") +
scale_y_continuous(
name = "CO2",
sec.axis = sec_axis(~., name = "d13C", labels = scales::number_format())
)
# Create a plot with CO2_ML and CO2_SAM
plot_co2 <- ggplot(data, aes(x = Year)) +
geom_point(aes(y = CO2_ML), col = "red") +
geom_point(aes(y = CO2_SAM), col = "blue") +
ylab("CO2")
# Create a plot with d13C_ML and d13C_SAM
plot_d13C <- ggplot(data, aes(x = Year)) +
geom_point(aes(y = d13C_ML), col = "red") +
geom_point(aes(y = d13C_SAM), col = "blue") +
ylab("d13C")
# Combine the two plots with separate y-axes
combined_plot <- plot_co2 +
geom_point(aes(y = d13C_ML), col = "green") +
geom_point(aes(y = d13C_SAM), col = "purple") +
scale_y_continuous(
name = "CO2",
sec.axis = sec_axis(~., name = "d13C", labels = scales::number_format())
)
# Print the combined plot
print(combined_plot)
# Combine the two plots with separate y-axes
combined_plot <- plot_co2 +
geom_point(aes(y = d13C_ML), col = "green") +
geom_point(aes(y = d13C_SAM), col = "purple") +
scale_y_continuous(
name = "CO2",
sec.axis = sec_axis(~., name = "d13C", labels = scales::number_format())
)
# Print the combined plot
print(combined_plot)
library(tidyverse)
library(tidyverse)
#finding the mean and standard deviation within each year, make a new data frame with this infro
annual_data <- data %>%
group_by(Year) %>%
summarise(
mean.CO2.ML = mean(CO2_ML),
annual.sd.CO2.ML = sd(CO2_ML),
mean.CO2.SAM = mean(CO2_SAM),
annual.sd.CO2.SAM = sd(CO2_SAM),
mean.d13C.ML = mean(d13C_ML),
annual.sd.d13C.ML = sd(d13C_ML),
mean.d13C.SAM = mean(d13C_SAM),
annual.sd.d13C.SAM = sd(d13C_SAM))
#find the difference between each time step
diff.CO2.ML <- vector(length = 39)
for(i in 1:39){
diff.CO2.ML[i] <- annual_data$mean.CO2.ML[i+1]-annual_data$mean.CO2.ML[i]
}
diff.CO2.SAM <- vector(length = 39)
for(i in 1:39){
diff.CO2.SAM[i] <- annual_data$mean.CO2.SAM[i+1]-annual_data$mean.CO2.SAM[i]
}
diff.d13C_ML <- vector(length = 39)
for(i in 1:39){
diff.d13C_ML[i] <- annual_data$mean.d13C.ML[i+1]-annual_data$mean.d13C.ML[i]
}
diff.d13C_SAM <- vector(length = 39)
for(i in 1:39){
diff.d13C_SAM[i] <- annual_data$mean.d13C.SAM[i+1]-annual_data$mean.d13C.SAM[i]
}
#average each set of differences to find the average change per year
mean(diff.CO2.ML[1:38])
mean(diff.CO2.SAM[1:38])
mean(diff.d13C_ML[1:38])
mean(diff.d13C_SAM[1:38])
```
print(coef(sourceLM.ML)[1]) # this is the y-intercept which is the source d13C value at ML
#ML
y.axis.ML <- data$d13C_ML
x.axis.ML <- 1/(data$CO2_ML)
sourceLM.ML <- lm((y.axis.ML ~
x.axis.ML))
print(coef(sourceLM.ML)[1]) # this is the y-intercept which is the source d13C value at ML
summary(sourceLM.ML)$coeff[1,2] #this is standard error of the y-intercept
#SAM
y.axis.SAM <- data$d13C_SAM
x.axis.SAM <- 1/data$CO2_SAM
sourceLM.SAM <- lm((y.axis.SAM ~ x.axis.SAM))
print(coef(sourceLM.SAM)[1]) # this is the y-intercept which is the source d13C value at SAM
summary(sourceLM.SAM)$coeff[1,2] #this is standard error of the y-intercept
#mean of each year subtract this from each data point
data$annual_mean_CO2_ML <- annual_data$mean.CO2.ML[match(data$Year, annual_data$Year)]
View(data)
data$annual_mean_d13C_ML <- annual_data$mean.d13C.ML[match(data$Year, annual_data$Year)]
data$annual_mean_CO2_SAM <- annual_data$mean.CO2.SAM[match(data$Year, annual_data$Year)]
data$annual_mean_d13C_SAM <- annual_data$mean.d13C.SAM[match(data$Year, annual_data$Year)]
ML_CO2 <- data$CO2_ML - data$annual_mean_CO2_ML
ML_CO2
ML_d13C <- data$d13C_ML - data$annual_mean_d13C_ML
ML_d13C
#take the original data point and subtract the mean
#creates vectors of data that are detrended
detrend_ML <- data$CO2_ML - data$annual_mean_CO2_ML
detrend_SAM <- data$CO2_SAM - data$annual_mean_CO2_SAM
detrend_d13C_ML <- data$d13C_ML - data$annual_mean_d13C_ML
detrend_d13C_SAM <- data$d13C_ML - data$annual_mean_d13C_SAM
#make a new data frame with the detrended data
detrend <- data.frame(detrend_d13C_ML, detrend_ML, detrend_d13C_SAM,detrend_SAM, data$Year)
#plot
ggplot(detrend, aes(x = data.Year, y = detrend_d13C_ML)) +
geom_point(color = "red") +
geom_point(aes(data.Year, detrend_ML), color = "blue")
ggplot(detrend, aes(x = data.Year, y = detrend_d13C_SAM)) +
geom_point(color = "red") +
geom_point(aes(data.Year, detrend_SAM), color = "blue")
View(detrend)
#plot for ML
ggplot(detrend, aes(x = data.Year, y = detrend_d13C_ML)) +
geom_point(color = "red") +
geom_point(aes(data.Year, detrend_ML))
x.lm.ML <- 1/detrend$detrend_ML
y.lm.ML <- detrend$detrend_d13C_ML
ggplot(detrend, aes(x = data.Year, y = detrend_d13C_SAM)) +
geom_point(color = "red") +
geom_point(aes(data.Year, detrend_SAM), color = "blue")
x.lm.ML <- 1/detrend$detrend_ML
y.lm.ML <- detrend$detrend_d13C_ML
LM.ML <- lm(y.lm.ML ~ x.lm.ML)
plot(detrend$data.Year,detrend$detrend_SAM)
print(coef(LM.ML))[1])
print(coef(LM.ML))[1]
print(coef(LM.ML)[1])
summary(LM.ML)$coeff[1,2]
View(data)
#find the y-intercepts for SAM
x.lm.SAM <- 1/detrend$detrend_SAM
y.lm.SAM <- detrend$detrend_d13C_SAM
LM.SAM <- lm(y.lm.SAM ~ x.lm.SAM)
print(coef(SAM.ML)[1])
LM.SAM <- lm(y.lm.SAM ~ x.lm.SAM)
print(coef(LM.SAM)[1])
summary(LM.SAM)$coeff[1,2]
print(coef(LM.ML)[1])
#plot
ggplot(detrend, aes(x = data.Year, y = detrend_d13C_ML)) +
geom_point(color = "red") +
geom_point(aes(data.Year, detrend_ML), color = "blue")
#plot
ggplot(detrend, aes(x = data.Year, y = detrend_d13C_ML)) +
geom_point(color = "red") +
geom_point(aes(data.Year, detrend_ML), color = "blue")
ggplot(detrend, aes(x = data.Year, y = detrend_d13C_SAM)) +
geom_point(color = "red") +
geom_point(aes(data.Year, detrend_SAM), color = "blue")
#method 2: cumulative for hydrogen
frac.cum.H <- (log((R.D.H[11]/R.D.H[1])/log(depth[11]/depth[1]))/10)+1
D.H <- c(-86.00, -84.70, -83.40, -81.70, -80.00, -78.70, -77.80,
-75.60, -73.50, -71.90, -72.10)
R.D.H <- (D.H/1000)+1
#method 1: sequential for hydrogen
frac.H <- vector(length= length(D.H))
for(i in 2:length(D.H)){
frac.H[i] <- log((R.D.H[i]/R.D.H[i-1])/log(depth[i]/depth[i-1]))+1
}
frac.H
#Set up vectors and then a data frame for the given numbers
depth <- seq(from = 5, to = 4, by = -0.1)
O18.O16 <- c(-12.00, -11.60, -11.20, -10.90, -10.30, -10.04,
-9.50, -9.00, -8.80, -8.20, -7.90)
D.H <- c(-86.00, -84.70, -83.40, -81.70, -80.00, -78.70, -77.80,
-75.60, -73.50, -71.90, -72.10)
R.D.H <- (D.H/1000)+1
#method 1: sequential for hydrogen
frac.H <- vector(length= length(D.H))
for(i in 2:length(D.H)){
frac.H[i] <- log((R.D.H[i]/R.D.H[i-1])/log(depth[i]/depth[i-1]))+1
}
frac.H
#method 1: sequential time intervals
frac <- vector(length = length(R.O18.O16))
for(i in 2:length(O18.O16)){
frac[i] <- log((R.O18.O16[i]/R.O18.O16[i-1]))/log(depth[i]/depth[i-1])+1
}
#Set up vectors and then a data frame for the given numbers
depth <- seq(from = 5, to = 4, by = -0.1)
function (..., list = character(), package = NULL, lib.loc = NULL,
verbose = getOption("verbose"), envir = .GlobalEnv, overwrite = TRUE)
knitr::opts_chunk$set(echo = TRUE)
#Set up vectors and then a data frame for the given numbers
depth <- seq(from = 5, to = 4, by = -0.1)
O18.O16 <- c(-12.00, -11.60, -11.20, -10.90, -10.30, -10.04,
-9.50, -9.00, -8.80, -8.20, -7.90)
R.O18.O16 <- (O18.O16/1000)+1
D.H <- c(-86.00, -84.70, -83.40, -81.70, -80.00, -78.70, -77.80,
-75.60, -73.50, -71.90, -72.10)
R.D.H <- (D.H/1000)+1
df <- data.frame(depth, O18.O16, D.H, R.O18.O16, R.D.H)
#method 1: sequential time intervals
frac <- vector(length = length(R.O18.O16))
for(i in 2:length(O18.O16)){
frac[i] <- log((R.O18.O16[i]/R.O18.O16[i-1]))/log(depth[i]/depth[i-1])+1
}
log((R.O18.O16[2]/R.O18.O16[1])/(depth[2]/depth[1]))+1
mean.frac <- mean(frac[2:11])
sd.frac <- sd(frac[2:11])
frac
mean.frac <- mean(frac[2:11])
mean.frac
#method 2: cumulative from initial condition
a <- R.O18.O16[11]/R.O18.O16[1]
b <- depth[11]/depth[1]
frac.cum <- (log(a)/log(b))+1 #divide by 10 because that is the number of total time steps that we are doing?
#convert frac values into delta notation
d.frac <- (mean.frac-1)*1000
d.frac
#method 1: sequential for hydrogen
frac.H <- vector(length= length(D.H))
for(i in 2:length(D.H)){
frac.H[i] <- log((R.D.H[i]/R.D.H[i-1]))/log(depth[i]/depth[i-1])+1
}
mean.frac.H <- mean(frac.H[2:11])
sd.frac.H <- sd(frac.H[2:11])
#method 2: cumulative for hydrogen
frac.cum.H <- (log((R.D.H[11]/R.D.H[1])/log(depth[11]/depth[1]))/10)+1
#method 2: cumulative for hydrogen
c <- R.D.H[11]/R.D.H[1]
d <- depth[11]/depth[1]
frac.cum.H <- ((log(c)/log(d))/10)+1
frac.cum.H
mean.frac.H
mean.frac
frac.cum
#method 1: sequential for hydrogen
frac.H <- vector(length= length(D.H))
for(i in 2:length(D.H)){
frac.H[i] <- log((R.D.H[i]/R.D.H[i-1]))/log(depth[i]/depth[i-1])+1
}
mean.frac.H <- mean(frac.H[2:11])
sd.frac.H <- sd(frac.H[2:11])
#method 2: cumulative for hydrogen
c <- R.D.H[11]/R.D.H[1]
d <- depth[11]/depth[1]
frac.cum.H <- ((log(c)/log(d))/10)+1
frac.cum.H
mean.frac.H
frac.H
sd.frac.H <- sd(frac.H[2:11])
sd.frac.H
R.D.H
frac.cum.H <- (log(c)/log(d))+1
<- mean(frac.H[2:11])
mean.frac.H
frac.cum.H
#convert frac values into delta notation
d.frac.H <- (mean.frac.H-1)*1000
d.frac.H
epsilon.O <- d.frac
epsilon.H <- d.frac.H
#Calculations of instantaneous product for oxygen
O18.O16 <- c(-12.00, -11.60, -11.20, -10.90, -10.30, -10.04,
-9.50, -9.00, -8.80, -8.20, -7.90)
inst.prod.O <- O18.O16 - epsilon.O
library(dplyr)
library(dplyr)
#Calculating cumulative product of O above the pool
cum.product.O <- cummean(inst.prod.O)
blank.correct <- read.csv(file = "~/Documents/GitHub/Isotope class/data/ProblemSet2/BlankCorrection.csv")
View(blank.correct)
blank.correct$Area.28[1]
blank.correct$Area.28[2]
M.I2 <- blank.correct$Area.28[1]
M.out <- blank.correct$Area.28[2]
M.out-M.I2
M.I2 <- blank.correct$Area.28[1]
M.out <- blank.correct$Area.28[2]
# use fraction 1 plus fraction 2 = 1 equation to solve for area under the curve if our sample had truly been JUST sample
M.I1 <- M.out-M.I2
M.I1
#Convert both delta notation values into R notation
R2 <- (4.315/1000)+1
R2
Rout <- (10.301/1000)+1
Rout
M.I1/M.out
#Use equation R = fI1*RI1 + fI2*RI2 to solve for the R value of the sample if there was not the confounding factor of atmospheric N
fI1 <- M.I1/M.out
#Use equation R = fI1*RI1 + fI2*RI2 to solve for the R value of the sample if there was not the confounding factor of atmospheric N
fI1 <- M.I1/M.out
fI2 <- M.I2/M.out
(Rout-(fI2*R2))/fI1
trueRsamp <- (Rout-(fI2*R2))/fI1
#convert the corrected Rsamp to delta
truedelta <- (trueRsamp*1000) + 1
truedelta
trueRsamp
#convert the corrected Rsamp to delta
truedelta <- (trueRsamp + 1) * 1000
truedelta
#convert the corrected Rsamp to delta
truedelta <- (trueRsamp 1 1) * 1000
truedelta
#convert the corrected Rsamp to delta
truedelta <- (trueRsamp - 1) * 1000
truedelta
#find the difference to figure out how much our original measurement was off by
diff <- truedelta - 10.301
diff
setwd("~/Documents/GitHub/CSIA_lab_work/data/SIA results")
setwd("~/Documents/GitHub/CSIA_lab_work/data/SIA results")
#Find correction factor from EA runs from the same time period as GC runs
library(readxl)
a <- read_xlsx(path = "231001_Jameson_20A-Snails.xls")
a <- read.csv(file = "231001_Jameson_20A-Snails.csv")
setwd("~/Documents/GitHub/CSIA_lab_work/data/SIA results")
a <- read.csv(file = "~/Documents/GitHub/CSIA_lab_work/data/SIA results/231001_Jameson_20A-Snails.csv")
a <- read.csv(file = "~/Documents/GitHub/CSIA_lab_work/data/SIA results/230914_Jameson_10B-AqPlants.csv")
View(a)
data <- read.csv(file = "~/Documents/GitHub/CSIA_lab_work/data/SIA results/230914_Jameson_10B-AqPlants.csv")
#Find correction factor from EA runs from the same time period as GC runs
data <- read.csv(file = "~/Documents/GitHub/CSIA_lab_work/data/SIA results/230914_Jameson_10B-AqPlants.csv")
### First EA run ###
#Load in data
data <- read.csv(file = "~/Documents/GitHub/CSIA_lab_work/data/SIA results/230914_Jameson_10B-AqPlants.csv")
dat_1 <- rnorm(30)
dat_yr <- ts(dat_1,
start = 1991, end = 2020,
frequency = 1)
dat_yr
plot.ts(dat_yr)
